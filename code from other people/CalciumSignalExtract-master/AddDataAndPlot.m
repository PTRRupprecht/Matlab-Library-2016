classdef AddDataAndPlot < handle
    %Class to adjust the ROI data (each cell's activity),
    %plots it and overlays behavioral data
    
    %THE ROI DATA CAN BE GENERATED BY THE GUI ITSELF AFTER A TIFF STACK HAS
    %BEEN PASSED IN
    
    %this class has two interface function (AddROIdataandScale and AddBehaviorData),
    %the first takes a matrix of ROI data (each roi is one column, each frame
    %is one row, where the first row indicates the ROI number), rescales it,
    %plots it (this data can also be created in the GUI):
    
    %LOAD IN EXCEL(txt) FILE WITH ROI INDEX FIRST ROW, format:
    % 1  2  3
    % 77 82 91
    % 77 89 90
    % 78 88 90
    
    %the second is the behavior data, which has information about the time
    %of a behavioral response (first row, in minutes), the kind of
    %behavioral response (second row, 0.8 means correct choice, 0.5 means
    %wrong choice, 0.2 means timeout). The third row indicated the
    %difficuly level (0-10) set during that response (not used here).
    %the 4th and 5th row indicate the presence of a stimulus. Row 4 is
    %again the timepoint of a stimulus event, and row 5 is the event.
    %For example the numer 12 (kind of stimulus) in row 5 and the number
    %0.04 in row 4 indicate that at time 0.04 the stimulus turned on.
    %For row 5, 12 means stimuls turned on at the right side, -1 means
    %stimulus turned off. 1 means stimulus turned on at the left side (then
    %usually followed again by -1 for stimulus off.
    
    %    %To interface with this class, use
    %
    %     PlotObject.AddBehaviorData(BehaviorData);
    %
    %     %Add ROI data
    %     PlotObject.AddRoiDataAndScale(ROI_data, y_spacing, x_spacing, do_normalize, offset_for_sync);
    %     %Add Behavior data
    %     PlotObject.AddBehaviorData(BehaviorData);
    %     %plot all
    %     PlotAll(GUI_handles, PlotObject,plot_two_windows, y_min, y_max);
    
    
    properties
        %data that needs to be added
        ROI_data;
        ROI_data_original;
        Behavior_matrix;
        Percent_correct;
        
        %extracted from above
        Responses_correct;
        Responses_correct_x;
        Responses_wrong;
        Responses_wrong_x;
        Stimulus_left_x;
        Stimulus_left_y;
        Stimulus_right_x;
        Stimulus_right_y;
        Max_y;
        DateHeader;
        %differen orientations if visual tuning curve is made
        Stimulus_0_x;
        Stimulus_0_y;
        Stimulus_12_x;
        Stimulus_12_y;
        Stimulus_22_x;
        Stimulus_22_y;
        Stimulus_33_x;
        Stimulus_33_y;
        Stimulus_45_x;
        Stimulus_45_y;
        Stimulus_56_x;
        Stimulus_56_y;
        Stimulus_67_x;
        Stimulus_67_y;
        Stimulus_78_x;
        Stimulus_78_y;
        Stimulus_90_x;
        Stimulus_90_y;
        Stimulus_101_x;
        Stimulus_101_y;
        Stimulus_112_x;
        Stimulus_112_y;
        Stimulus_123_x;
        Stimulus_123_y;
        Stimulus_135_x;
        Stimulus_135_y;
        Stimulus_146_x;
        Stimulus_146_y;
        Stimulus_157_x;
        Stimulus_157_y;
        Stimulus_168_x;
        Stimulus_168_y;
        Stimulus_180_x;
        Stimulus_180_y;
        Stimulus_202_x;
        Stimulus_202_y;
        Stimulus_225_x;
        Stimulus_225_y;
        Stimulus_247_x;
        Stimulus_247_y;
        Stimulus_270_x;
        Stimulus_270_y;
        Stimulus_292_x;
        Stimulus_292_y;
        Stimulus_315_x;
        Stimulus_315_y;
        Stimulus_337_x;
        Stimulus_337_y;
        Stim_legend_string = [];
        
    end
    
    
    methods
        
        function AddRoiDataAndScale(this , ROI_matrix_in, scale_value_offset, delta_value_x, normalize_to_100, Offset_for_sync)
            this.ROI_data_original = ROI_matrix_in;
            ROI_data_temp = [];
            %compensate for delay with trigger
            OFFSETDELAY = 0.01;
            
            %for 256*128 scab the frame length is 0.297s
            %normalize them all to have 100 as max
            if normalize_to_100 == 1
                
                for column = 1:size(this.ROI_data_original,2)
                    %find max
                    max_signal = max(this.ROI_data_original(:,column));
                    %normalize to max
                    ROI_data_temp(:,column)=this.ROI_data_original(:,column)/max_signal;
                end
                
                %update data
                ROI_matrix_in = ROI_data_temp;
                ROI_data_temp = [];
            end
            
            %add offset to each value in column
            for i = 1:size(ROI_matrix_in,2)
                
                ROI_data_temp(:,i)=ROI_matrix_in(:,i)+scale_value_offset*i-scale_value_offset;
                
            end
            
            %change delta scaling of the x axis
            for i = 1:size(ROI_matrix_in,1)
                ROI_data_temp(i,1) = ((delta_value_x*i)-delta_value_x)/60+Offset_for_sync-OFFSETDELAY;
                % ROI_data_temp(i,1) = (delta_value_x*i-delta_value_x)/60;
            end
            
            %find highest value
            this.Max_y = max(ROI_data_temp(:,size(ROI_matrix_in,2)));
            this.ROI_data = ROI_data_temp;
        end
        
        function AddBehaviorData(this, behavior_matrix_in)
            this.Behavior_matrix = behavior_matrix_in;
            this.Extract_correct_wrong();
            this.Extract_Stimulus_left_right();
        end
        
        function Extract_correct_wrong(this)
            %split data into separate correct/wrong vectors
            i = 1;
            MAX = this.Max_y;
            MIN = 0;
            
            %count all and create percent correct
            Percent_correct = 0;
            correct_count = 0;
            wrong_count = 0;
            
            %keep all values at 0 if there is no response. If there is one,
            %set it to max, then create a new x time point right after and
            %set y back to 0, so on the plot it is a straing vertical line
            %start at 0
            
            this.Responses_correct_x(end+1) = 0;
            this.Responses_correct(end+1) = MIN;
            this.Responses_wrong_x(end+1) = 0;
            this.Responses_wrong(end+1) = MIN;
            
            while this.Behavior_matrix(1,i) ~= 0
                
                %if correct
                if this.Behavior_matrix(2,i) == 0.8
                    
                    %create an extra entry right before in time to
                    %start low
                    this.Responses_correct_x(end+1) = this.Behavior_matrix(1,i)-0.000001;
                    this.Responses_correct(end+1) = MIN;
                    %raise to max
                    this.Responses_correct_x(end+1) = this.Behavior_matrix(1,i);
                    this.Responses_correct(end+1) = MAX;
                    %create an extra entry right after in time to lower
                    %back to min
                    this.Responses_correct_x(end+1) = this.Behavior_matrix(1,i)+0.000001;
                    this.Responses_correct(end+1) = MIN;
                    correct_count = correct_count+1;
                    
                    %if wrong
                elseif this.Behavior_matrix(2,i) == 0.5
                    %create an extra entry right before in time to
                    %start low
                    this.Responses_wrong_x(end+1) = this.Behavior_matrix(1,i)-0.000001;
                    this.Responses_wrong(end+1) = MIN;
                    %raise to max
                    this.Responses_wrong_x(end+1) = this.Behavior_matrix(1,i);
                    this.Responses_wrong(end+1) = MAX;
                    %create an extra entry right after in time to lower
                    %back to min
                    this.Responses_wrong_x(end+1) = this.Behavior_matrix(1,i)+0.000001;
                    this.Responses_wrong(end+1) = MIN;
                    wrong_count = wrong_count + 1;
                    
                end
                
                i = i+1;
            end
            
            this.Percent_correct = correct_count/(correct_count+wrong_count);
            
        end
        
        function Extract_Stimulus_left_right(this)
            %split data into separate left/right matrixes
            %to plot the data, use "patch" which draws a box bound to when
            %the stimulus is on. Patch uses two vectors, first is x = [x1,
            %x2, x3, x4], then each has a corresponding y coordinate y =
            %[y1, y2, y3, y4]. To plot a box starting at t0 to t1, having
            %the height starting at x0 to x1, use these:
            %patch_y = [min, min, max, max]
            %patch_x = [t0, t1, t1, t0]
            %(patch would get drawn starting at bottom left point, then
            %bottom right, then up to top right and left to top left.
            %store all these patch vectors in a vector (so a matrix total)
            %then iterate through the rows to plot.
            
            MAX = this.Max_y;
            MIN = 0;
            patch_y = [0, 0, 0, 0];
            patch_x = [0, 0, 0, 0];
            
            %1 = left, 11/12 = right, -1 is close
            
            for i =1:length(this.Behavior_matrix(5,:))
                
                %add current time to temp coordinates as start of
                %patch. Usually each open gets followed by a close,
                %so using +1 of i on the time vector should get the
                %closing time, to make sure that it does, check,
                %and if not, add it to the data
                
                %if current stim open ID is the last entrance,
                %there is no closing event recorded, so add one
                %right after.
                if i == length(this.Behavior_matrix(5,:))
                    this.Behavior_matrix(4,i+1) = this.Behavior_matrix(4,i)+0.001;
                end
                patch_x = [this.Behavior_matrix(4,i), this.Behavior_matrix(4,i+1), this.Behavior_matrix(4,i+1), this.Behavior_matrix(4,i)];
                patch_y = [MIN, MIN, MAX, MAX];
                
                
                %if not found in legend string, add
                found = find(this.Stim_legend_string==this.Behavior_matrix(5,i));
                if size(found,2) == 0 && this.Behavior_matrix(5,i) ~= -1
                    
                   this.Stim_legend_string(end+1) = this.Behavior_matrix(5,i);
                end
                %add to matrix
                
                switch this.Behavior_matrix(5,i)
                    
                    %if the ID for the stimulus matched left (1)
                    case 1
                        this.Stimulus_left_x(end+1,1:4)= patch_x;
                        this.Stimulus_left_y(end+1,1:4)= patch_y;
                        
                        
                        %if the ID for the stimulus matched right (11)
                    case 11
                        this.Stimulus_right_x(end+1,1:4)= patch_x;
                        this.Stimulus_right_y(end+1,1:4)= patch_y;
                        
                        %if they match other orientations
                    case 0
                        this.Stimulus_0_x(end+1,1:4)= patch_x;
                        this.Stimulus_0_y(end+1,1:4)= patch_y;
                        
                    case 12
                        this.Stimulus_12_x(end+1,1:4)= patch_x;
                        this.Stimulus_12_y(end+1,1:4)= patch_y;
                        
                    case 22
                        this.Stimulus_22_x(end+1,1:4)= patch_x;
                        this.Stimulus_22_y(end+1,1:4)= patch_y;
                        
                    case 33
                        this.Stimulus_33_x(end+1,1:4)= patch_x;
                        this.Stimulus_33_y(end+1,1:4)= patch_y;
                        
                    case 45
                        this.Stimulus_45_x(end+1,1:4)= patch_x;
                        this.Stimulus_45_y(end+1,1:4)= patch_y;
                        
                    case 56
                        this.Stimulus_56_x(end+1,1:4)= patch_x;
                        this.Stimulus_56_y(end+1,1:4)= patch_y;
                        
                    case 67
                        this.Stimulus_67_x(end+1,1:4)= patch_x;
                        this.Stimulus_67_y(end+1,1:4)= patch_y;
                        
                    case 78
                        this.Stimulus_78_x(end+1,1:4)= patch_x;
                        this.Stimulus_78_y(end+1,1:4)= patch_y;
                        
                    case 90
                        this.Stimulus_90_x(end+1,1:4)= patch_x;
                        this.Stimulus_90_y(end+1,1:4)= patch_y;
                        
                    case 101
                        this.Stimulus_101_x(end+1,1:4)= patch_x;
                        this.Stimulus_101_y(end+1,1:4)= patch_y;
                        
                    case 112
                        this.Stimulus_112_x(end+1,1:4)= patch_x;
                        this.Stimulus_112_y(end+1,1:4)= patch_y;
                        
                    case 123
                        this.Stimulus_123_x(end+1,1:4)= patch_x;
                        this.Stimulus_123_y(end+1,1:4)= patch_y;
                        
                    case 135
                        this.Stimulus_135_x(end+1,1:4)= patch_x;
                        this.Stimulus_135_y(end+1,1:4)= patch_y;
                        
                    case 146
                        this.Stimulus_146_x(end+1,1:4)= patch_x;
                        this.Stimulus_146_y(end+1,1:4)= patch_y;
                        
                    case 157
                        this.Stimulus_157_x(end+1,1:4)= patch_x;
                        this.Stimulus_157_y(end+1,1:4)= patch_y;
                        
                    case 168
                        this.Stimulus_168_x(end+1,1:4)= patch_x;
                        this.Stimulus_168_y(end+1,1:4)= patch_y;
                        
                    case 180
                        this.Stimulus_180_x(end+1,1:4)= patch_x;
                        this.Stimulus_180_y(end+1,1:4)= patch_y;
                        
                    case 202
                        this.Stimulus_202_x(end+1,1:4)= patch_x;
                        this.Stimulus_202_y(end+1,1:4)= patch_y;
                        
                    case 225
                        this.Stimulus_225_x(end+1,1:4)= patch_x;
                        this.Stimulus_225_y(end+1,1:4)= patch_y;
                        
                    case 247
                        this.Stimulus_247_x(end+1,1:4)= patch_x;
                        this.Stimulus_247_y(end+1,1:4)= patch_y;
                        
                    case 270
                        this.Stimulus_270_x(end+1,1:4)= patch_x;
                        this.Stimulus_270_y(end+1,1:4)= patch_y;
                        
                    case 292
                        this.Stimulus_292_x(end+1,1:4)= patch_x;
                        this.Stimulus_292_y(end+1,1:4)= patch_y;
                        
                    case 315
                        this.Stimulus_315_x(end+1,1:4)= patch_x;
                        this.Stimulus_315_y(end+1,1:4)= patch_y;
                        
                    case 337
                        this.Stimulus_337_x(end+1,1:4)= patch_x;
                        this.Stimulus_337_y(end+1,1:4)= patch_y;
                end
                
            end
            
        end
        
    end
    
    methods(Static = true)
        
    end
    
end

